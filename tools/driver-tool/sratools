#!/usr/bin/env perl

use strict;
use warnings;
use IO::Handle;
use File::Spec;

#use Data::Dumper;

use constant { TRUE => !0, FALSE => !!0 };
use constant EXIT_CODE_TRY_NEXT_SOURCE => 9; ### TODO: UPDATE TO CORRECT CODE AFTER TOOLS ARE UPDATED
use constant {
    REAL_SAM_DUMP => 'sam-dump-orig',
    REAL_FASTQ_DUMP => 'fastq-dump-orig',
    REAL_FASTERQ_DUMP => 'fasterq-dump-orig',
};

sub expandAllAccessions(@);
sub resolveAccessionURLs($);
sub processArgv($\@\@\%\%@);
sub help_path($$);
sub runtool($$$$$@);
sub which($);
sub help(@);
sub info(@);
sub extract(@);
sub usage();

my ($selfvol, $selfdir, $base) = File::Spec->splitpath($0);
my $selfpath = File::Spec->rel2abs(File::Spec->catpath($selfvol, $selfdir, ''));

goto RUNNING_AS_FASTQ_DUMP      if $base eq 'fastq-dump';
goto RUNNING_AS_FASTERQ_DUMP    if $base eq 'fasterq-dump';
goto RUNNING_AS_SAM_DUMP        if $base eq 'sam-dump';

usage() unless @ARGV;

my $cmd = shift;
help(@ARGV) if $cmd eq 'help';
info(@ARGV) if $cmd eq 'info';
extract('-format=fastq', @ARGV) if $cmd eq 'fastq';
extract('-format=sam', @ARGV) if $cmd eq 'sam';
usage();
## unreachable

### \brief: runs tool on list of accessions
###
### \param: tool name
### \param: full path to tool
### \param: tool parameters
### \param: the list of accessions to process
###
### \return: DOES NOT RETURN; calls exit
sub processAccessions($$\@@)
{
    my $toolname = shift;
    my $toolpath = shift;
    my $params = shift;
    my @runs = expandAllAccessions(@_);
    
    foreach (@runs) {
        my $run = $_;
        my @sources = resolveAccessionURLs($run);
        foreach (@sources) {
            my ($runURL, $cacheURL) = ( $_->{'url'}, $_->{'cache'} );
            
            # print STDERR "# running $toolpath with runURL='$runURL' and ".($cacheURL ? "cacheURL='$cacheURL'" : "no cacheURL").".\n";
            # print STDERR "# $tool ".join(", ", @_)." $accession\n";

            my $kid = fork(); die "can't fork: $!" unless defined $kid;            
            if ($kid == 0) {
                $ENV{VDB_REMOTE_URL} = $runURL;
                $ENV{VDB_REMOTE_CACHE_URL} = $cacheURL // '';
    
                exec {$toolpath} $toolname, @$params, $accession;
                die "can't exec $tool: $!";
            }
            waitpid($kid, 0);

            last if $? == 0; # SUCCESS! process the next run
            exit ($? >> 8) if ($? & 0xFF) != 0; # abnormal end
            exit ($? >> 8) unless ($? >> 8) == EXIT_CODE_TRY_NEXT_SOURCE; # it's an error we can't handle
        }
    }
    exit 0;
}

RUNNING_AS_FASTQ_DUMP:
{
    my $toolpath = which(REAL_FASTQ_DUMP) or help_path(REAL_FASTQ_DUMP, TRUE);
    my %long_arg = (
        '-A' => '--accession',
        '-N' => '--minSpotId',
        '-X' => '--maxSpotId',
        '-W' => '--clip',
        '-M' => '--minReadLen',
        '-R' => '--read-filter',
        '-E' => '--qual-filter',
        '-O' => '--outdir',
        '-Z' => '--stdout',
        '-G' => '--spot-group',
        '-T' => '--group-in-dirs',
        '-K' => '--keep-empty-files',
        '-C' => '--dumpcs',
        '-B' => '--dumpbase',
        '-Q' => '--offset',
        '-F' => '--origfmt',
        '-I' => '--readids',
        '-V' => '--version',
        '-L' => '--log-level',
        '-v' => '--verbose',
        '-+' => '--debug',
        '-h' => '--help',
        '-?' => '--help',
    );
    my %param_has_arg = (
        '--accession' => TRUE,
        '--table' => TRUE,
        '--minSpotId' => TRUE,
        '--maxSpotId' => TRUE,
        '--spot-groups' => TRUE,
        '--minReadLen' => TRUE,
        '--read-filter' => TRUE,
        '--aligned-region' => TRUE,
        '--matepair-distance' => TRUE,
        '--outdir' => TRUE,
        '--offset' => TRUE,
        '--defline-seq' => TRUE,
        '--defline-qual' => TRUE,
        '--log-level' => TRUE,
        '--debug' => TRUE,
        '--dumpcs' => 0, # argument not required
        '--fasta' => 0, # argument not required
    );
    my @params = (); # short params get expanded to long form
    my @args = (); # everything that isn't part of a parameter

    if (!processArgv('old', @params, @args, %long_arg, %param_has_arg, @ARGV))
    {
        # usage error or user asked for help
        exec {$toolpath} 'fastq-dump', '--help';
        die "can't exec original fastq-dump: $!";
    }
    processAccessions('fastq-dump', $toolpath, @params, @args);
    # unreachable
}

RUNNING_AS_FASTERQ_DUMP:
{
    my $toolpath = which(REAL_FASTERQ_DUMP) or help_path(REAL_FASTERQ_DUMP, TRUE);
    my %long_arg = (
        '-o' => '--outfile',
        '-O' => '--outdir',
        '-b' => '--bufsize',
        '-c' => '--curcache',
        '-m' => '--mem',
        '-t' => '--temp',
        '-e' => '--threads',
        '-p' => '--progress',
        '-x' => '--details',
        '-s' => '--split-spot',
        '-S' => '--split-files',
        '-3' => '--split-3',
        '-f' => '--force',
        '-N' => '--rowid-as-name',
        '-P' => '--print-read-nr',
        '-M' => '--min-read-len',
        '-B' => '--bases',
        '-V' => '--version',
        '-L' => '--log-level',
        '-v' => '--verbose',
        '-+' => '--debug',
        '-h' => '--help',
        '-?' => '--help',
    );
    my %param_has_arg = (
        '--outfile' => TRUE,
        '--outdir' => TRUE,
        '--bufsize' => TRUE,
        '--curcache' => TRUE,
        '--mem' => TRUE,
        '--temp' => TRUE,
        '--threads' => TRUE,
        '--min-read-len'=> TRUE,
        '--log-level' => TRUE,
        '--debug' => TRUE,
    );
    my @params = (); # short params get expanded to long form
    my @args = (); # everything that isn't part of a parameter

    if (!processArgv('new', @params, @args, %long_arg, %param_has_arg, @ARGV))
    {
        # usage error or user asked for help
        exec {$toolpath} 'fasterq-dump', '--help';
        die "can't exec original fasterq-dump: $!";
    }
    processAccessions('fasterq-dump', $toolpath, @params, @args);
    # unreachable
}

RUNNING_AS_SAM_DUMP:
{
    my $toolpath = which(REAL_SAM_DUMP) or help_path(REAL_SAM_DUMP, TRUE);
    my %long_arg = (
        '-u' => '--unaligned',
        '-1' => '--primary',
        '-c' => '--cigar-long',
        '-r' => '--header',
        '-n' => '--no-header',
        '-s' => '--seqid',
        '-=' => '--hide-identical',
        '-g' => '--spot-group',
        '-p' => '--prefix',
        '-Q' => '--qual-quant',
        '-V' => '--version',
        '-L' => '--log-level',
        '-v' => '--verbose',
        '-+' => '--debug',
        '-h' => '--help',
        '-?' => '--help',
    );
    my %param_has_arg = (
        '--header-file' => TRUE,
        '--header-comment' => TRUE,
        '--aligned-region' => TRUE,
        '--matepair-distance' => TRUE,
        '--prefix' => TRUE,
        '--qual-quant' => TRUE,
        '--log-level' => TRUE,
        '--debug' => TRUE,
    );
    my @params = (); # short params get expanded to long form
    my @args = (); # everything that isn't part of a parameter

    if (!processArgv('new', @params, @args, %long_arg, %param_has_arg, @ARGV))
    {
        # usage error or user asked for help
        exec {$toolpath} 'sam-dump', '--help';
        die "can't exec original sam-dump: $!";
    }
    processAccessions('sam-dump', $toolpath, @params, @args);
    # unreachable
}

### \brief: turns an accession into its constituent run accessions
###
### \param: the query accession
###
### \return: array of run accessions
###
### currently, this is a stub that returns an empty array
sub expandAccession($)
{
    my @rslt = ();
    # TODO 
    return @rslt;
}

### \brief: turns a list of accessions into constituent run accessions
###
### \param: array of query accessions
###
### \return: array of run accessions, array is uniqued, in order of first encounter
###
### currently, this is a stub that only works for run accessions
sub expandAllAccessions(@)
{
    my @rslt;
    my %seen = ();
    foreach (@_) {
        if (/^[EDS]RR\d+$/) {
            next if $seen{$_};
            push @rslt, $_;
            $seen{$_} = TRUE;
        }
        my @runs = expandAccession($_);
        foreach (@runs) {
            next if $seen{$_};
            push @rslt, $_;
            $seen{$_} = TRUE;
        }
    }
    return @rslt;
}

### \brief: turns an accession into URLs
###
### \param: the accession
###
### \return: array of possible pairs of URLs to data and maybe to vdbcache files
###
### currently, this is a stub that just uses srapath
sub resolveAccessionURLs($)
{
    my $toolpath = which('srapath') or help_path('srapath', TRUE);
    my @result;
    my $kid = open(my $pipe, '-|', $toolpath, $_[0]) or die "can't fork or can't exec srapath: $!";

    while (defined(local $_ = <$pipe>)) {
        chomp;
        push @result, {
            source => undef, url => $_, cache => undef
        };
    }
    close($pipe);
    return @result;
}

### \brief: the info sub-command
###
### \param: command line ARGS
###
### \return: does not return; calls exit
sub info(@)
{
    exit 0;
}

### \brief: the extract sub-command
###
### \param: command line ARGS
###
### \return: does not return; calls exit
sub extract(@)
{
    exit 0;
}

### \brief: the help sub-command
###
### \param: command line ARGS
###
### \return: does not return; calls exit
sub help(@)
{
    local $0 = $base;
    
    goto INFO if $_[0] && $_[0] eq 'info';
    goto FASTQ if $_[0] && $_[0] eq 'fastq';
    goto SAM if $_[0] && $_[0] eq 'sam';
    
    print "Usage: $0 <command> [<args> ...]\n";
    print <<"EOF";
Commands are:
    info  - get info for an SRA accession
    fastq - extract FASTQ from an SRA accession
    sam   - extract SAM from an SRA accession
    
    help <command> - detailed help for <command> or this message
    
About SRA accessions:
    SRA accessions come in several types. Most types are containers of other
    types, except for SRA run accessions which contain sequence data. Only SRA
    run accessions may be extracted. This tool will expand container accessions
    to their constituent run accessions and perform the requested function on
    each.
    
    SRA run accessions can be extracted as FASTQ.
    
    SRA run accessions can be extracted as SAM; if the run contains alignments,
    the alignment information will be in the SAM records for the aligned reads.
    
    SRA does not guarantee that the original read names are preserved. SRA does
    guarantee that the identity of the reads and mate-pairs are preserved.
    
    SRA does not guarantee that the original quality scores are preserved.
    
See also:
    The SRA homepage at NCBI:
    https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi

    The SRA Toolkit homepage, where you may obtain the latest versions of this
    software and related tools:
    https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software
EOF
    exit 0;

  INFO:
    print <<"EOM";
Usage: $0 info <object>
Prints detailed information about an SRA object
EOM
    exit 0;

  FASTQ:
    print <<"EOM";
Usage: $0 fastq <object>
Extract FASTQ from (possibly many) SRA run accessions
EOM
    exit 0;

  SAM:
    print <<"EOM";
Usage: $0 info <object>
Extract SAM from (possibly many) SRA run accessions
EOM
    exit 0;
}

sub help_path($$)
{
    print "could not find $_[0]";
    print $_[1] ? ", which is part of this software distrobution\n" : "\n";
    print <<"EOM";
This can be fixed in one of the following ways:
* adding $_[0] to the directory that contains this tool, i.e. $selfpath
* adding the directory that contains $_[0] to the PATH environment variable
* adding $_[0] to the current directory
EOM
    exit 78; # EX_CONFIG from <sysexits.h>
}

### \brief: prints basic usage message
###
### \return: does not return; calls exit
sub usage()
{
    print "Usage: $base <command> [<args> ...]\nTry\n   $base help\n";
    exit 64; # EX_USAGE from <sysexits.h>
}

### \brief: check if path+file is an executable
###
### \param: executable name
### \param: directory to examine
###
### \return: path+file if it exists and is executable
sub isExecutable($$)
{
    my ($vol, $dirs, undef) = File::Spec->splitpath($_[1], !0);
    local $_ = File::Spec->catpath($vol, $dirs, $_[0]);
    return (-e && -x) ? $_ : undef;
}

### \brief: like shell `which` but checks more than just PATH
###
### \param: executable name
###
### \return: the full path to executable or undef
sub witch($)
{
    my $exe = $_[0];
    my $fullpath;

    ## first check self directory
    $fullpath = isExecutable($exe, $selfpath);
    return $fullpath if $fullpath;

    ## check PATH
    local $_;
    foreach (File::Spec->path()) {
        $fullpath = isExecutable($exe, $_);
        return $fullpath if $fullpath;
    }

    ## lastly check current directory
    return isExecutable($exe, File::Spec->curdir());
}

### \brief: memo-ized which
###
### \param: executable name
###
### \return: the full path to executable or undef
my %which_mem = ();
sub which($)
{
    $which_mem{$_[0]} = witch($_[0]) unless exists $which_mem{$_[0]};
    return $which_mem{$_[0]};
}

sub runtool($$$$$@)
{
    my $tool = shift;
    my $toolpath = shift;
    my $accession = shift;
    my $runURL = shift;
    my $cacheURL = shift;
    
    print STDERR "# running $toolpath with runURL='$runURL' and ".($cacheURL ? "cacheURL='$cacheURL'" : "no cacheURL").".\n";
    # print STDERR "# $tool ".join(", ", @_)." $accession\n";
    # return 'DUMMY';
    
    my $kid = fork(); die "can't fork: $!" unless defined $kid;
    
    return $kid if $kid;
    
    # child process
    $ENV{VDB_REMOTE_URL} = $runURL;
    $ENV{VDB_REMOTE_CACHE_URL} = $cacheURL // '';
    
    exec {$toolpath} $tool, @_, $accession;
    die "can't exec $tool: $!";
}

### \brief: process ARGV using fastq-dump style parsing rules
###
### \param: params   - out, by ref; array of parameters
### \param: args     - out, by ref; array of arguments
### \param: longName - by ref; hash mapping short to long parameter names
### \param: hasArg   - by ref; hash specifying which parameters may take arguments
### \param: argv
sub processArgvOldStyle(\@\@\%\%@)
{
# parameter may be long or short form
# each parameter must be a separate element (always `-X -C`; never `-XC`)
# parameter arguments must follow parameter as a separate element (never `--param=value` or `-Xvalue`)

    my $params = shift;
    my $args = shift;
    my $longArg = shift;
    my $hasArg = shift;

    while (@_) {
        my $param;
        
        if ($_[0] !~ /^-/) { # ordinary argument
            local $_ = shift;
            push @$args, $_;
            next;
        }
        if ($_[0] =~ /^--/) { # long param
            $param = shift;
        }
        else { # short param
            local $_ = shift;
            $param = $longArg->{$_};
        }
        return FALSE if $param eq '--help';
        if (exists $hasArg->{$param}) {
            if ($hasArg->{$param}) { # param requires an argument
                return FALSE unless @_;
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
            elsif (@_ && $_[0] !~ /^-/) {
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
        }
        # this parameter never has an argument or
        # optional argument wasn't given
        push @$params, $param;
    }
    return TRUE;
}

### \brief: process ARGV
###
### \param: style    - style of args parsing: 'old' = like fastq-dump
### \param: params   - out, by ref; array of parameters
### \param: args     - out, by ref; array of arguments
### \param: longName - by ref; hash mapping short to long parameter names
### \param: hasArg   - by ref; hash specifying which parameters may take arguments
### \param: argv
sub processArgv($\@\@\%\%@)
{
    {
        my $style = shift;
        goto &processArgvOldStyle if $style eq 'old';
    }
# parameter may be long or short form
# parameter arguments may follow as a separate element
# parameter arguments may be attached to parameter name with an equals
# short form parameter arguments may be attached directly to parameter
# converts short form to long form
# converts `--param=arg` to `--param arg`

    my $params = shift;
    my $args = shift;
    my $longArg = shift;
    my $hasArg = shift;

    while (@_) {        
        unless ($_[0] =~ /^-/) {
            # ordinary argument
            local $_ = shift;
            push @$args, $_;
            next;
        }

        my $param = shift;
        if ($param =~ /^--/ ) {
            if ($param =~ /^(--[^=]+)=(.+)$/) {
                # convert `--param=arg` to `--param arg`
                push @$params, $1, $2;
                next;
            }
        }
        else {
            # short form
            if ($param =~ /^(-.)(.+)$/) {
                $param = $longArg->{$1};
                if (exists $hasArg->{$param}) {
                    # convert short form with concatenated arg to long form with separate arg
                    push @$params, $param, $2;
                    next;
                }
                else {
                    # concatenated short form; put back the remainder
                    unshift @_, "-$2";
                    push @$params, $param;
                    next;
                }
            }
            else {
                $param = $longArg->{$param};
            }
        }
        return FALSE if $param eq '--help';
        if (exists $hasArg->{$param}) {
            if ($hasArg->{$param}) { # argument is required
                return FALSE unless @_;
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
            elsif (@_ && $_[0] !~ /^-/) { # argument is optional
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
        }
        # this parameter never has an argument or
        # optional argument wasn't given
        push @$params, $param;
    }
    return TRUE;
}
