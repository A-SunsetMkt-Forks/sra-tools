#!/usr/bin/env perl

use v5.16;
use strict;
use warnings;
use IO::Handle;
use File::Spec;
use JSON::PP;
use LWP;
use URI;
use XML::LibXML;

use constant { TRUE => !0, FALSE => !!0 };
use constant EXIT_CODE_TRY_NEXT_SOURCE => 9; ### TODO: UPDATE TO CORRECT CODE AFTER TOOLS ARE UPDATED
use constant {
    REAL_SAM_DUMP => 'sam-dump-orig',
    REAL_FASTQ_DUMP => 'fastq-dump-orig',
    REAL_FASTERQ_DUMP => 'fasterq-dump-orig',
};

my ($selfvol, $selfdir, $basename) = File::Spec->splitpath($0);
my $selfpath = File::Spec->rel2abs(File::Spec->catpath($selfvol, $selfdir, ''));

goto RUNNING_AS_FASTQ_DUMP      if $basename eq 'fastq-dump';
goto RUNNING_AS_FASTERQ_DUMP    if $basename eq 'fasterq-dump';
goto RUNNING_AS_SAM_DUMP        if $basename eq 'sam-dump';

goto RUN_TESTS if $ENV{DRIVER_TOOL_RUN_TESTS};

sub usage();
sub help(@);
sub info(@);
sub extract(@);

usage() unless @ARGV;

$_ = shift;
help(@ARGV) if /^help$/;
info(@ARGV) if /^info$/;
extract('-format=fastq', @ARGV) if /^fastq$/;
extract('-format=sam', @ARGV) if /^sam$/;
unshift @ARGV, $_;
usage();
die "unreachable";

sub expandAllAccessions(@);
sub resolveAccessionURLs($);
sub parseArgv($\@\@\%\%@);
sub help_path($$);
sub which($);

### \brief: runs tool on list of accessions
###
### After args parsing, this is called to do the meat of the work.
### Accession can be any kind of SRA accession.
###
### \param: tool name, e.g. fastq-dump
### \param: full path to tool, e.g. /path/to/fastq-dump-orig
### \param: tool parameters; arrayref
### \param: the list of accessions to process
###
### \return: DOES NOT RETURN; calls exit
sub processAccessions($$\@@)
{
    my $toolname = shift;
    my $toolpath = shift;
    my $params = shift;
    my @runs = expandAllAccessions(@_);
    
    foreach my $run (@runs) {
        my @sources = resolveAccessionURLs($run);
        foreach (@sources) {
            my ($runURL, $cacheURL) = @$_{'url', 'cache'};
            
            # print STDERR "# running $toolpath with runURL='$runURL' and ".($cacheURL ? "cacheURL='$cacheURL'" : "no cacheURL").".\n";
            # print STDERR "# $tool ".join(", ", @_)." $accession\n";

            my $kid = fork(); die "can't fork: $!" unless defined $kid;            
            if ($kid == 0) {
                $ENV{VDB_REMOTE_URL} = $runURL;
                $ENV{VDB_REMOTE_CACHE_URL} = $cacheURL // '';
    
                exec {$toolpath} $toolname, @$params, $run;
                die "can't exec $toolname: $!";
            }
            waitpid($kid, 0);

            last if $? == 0; # SUCCESS! process the next run
            exit ($? >> 8) if ($? & 0xFF) != 0; # abnormal end
            exit ($? >> 8) unless ($? >> 8) == EXIT_CODE_TRY_NEXT_SOURCE; # it's an error we can't handle
        }
    }
    exit 0;
}

sub expandAccession($);

### \brief: turns a list of accessions into constituent run accessions
###
### \param: array of query accessions
###
### \return: array of run accessions, array is uniqued, in order of first encounter
###
### currently, this is a stub that only works for run accessions
sub expandAllAccessions(@)
{
    my @rslt;
    my %seen = ();

    while (@_) {
        local $_ = shift;
        next if $seen{$_};
        $seen{$_} = TRUE;
        
        # check for ordinary run accessions, e.g. SRR000001 ERR000001 DRR000001
        if (/^[DES]RR\d+$/) {
            push @rslt, $_;
            next;
        }
        # check if it is a file
        if (-f) {
            push @rslt, $_;
            next;
        }
        # see if it can be expanded into run accessions
        push @_, expandAccession($_);
    }
    return @rslt;
}

### \brief: turns an accession into URLs
###
### \param: the accession
###
### \return: array of possible pairs of URLs to data and maybe to vdbcache files
###
### currently, this is a stub that just uses srapath
sub resolveAccessionURLs($)
{
    my $toolpath = which('srapath') or help_path('srapath', TRUE);
    my @result;
    my $kid = open(my $pipe, '-|', $toolpath, $_[0]) or die "can't fork or can't exec srapath: $!";

    while (defined(local $_ = <$pipe>)) {
        ## TODO: proper parsing of new? srapath response
        chomp;
        push @result, {
              source => undef
            , url => $_
            , cache => undef
        };
    }
    close($pipe);
    return @result;
}

use constant EUTILS_URL => URI->new('https://eutils.ncbi.nlm.nih.gov/entrez/eutils/');

### \brief: run a query with eutils
###
### \param: the LWP::UserAgent
### \param: the search term
###
### \return: array of matching IDs
sub queryEUtils($$)
{
    my $ua = shift;
    my $url = URI->new_abs('esearch.fcgi', EUTILS_URL);
    $url->query_form(retmode => 'json', db => 'sra', term => shift); # TODO: Disable result limit of 20

    my $res = $ua->get($url); die $res->status_line unless $res->is_success;

    my $obj = decode_json $res->content;
    my $result = $obj->{esearchresult} or die "unexpected response from eutils";
    my $idlist = $result->{idlist} or die "unexpected response from eutils";
    
    return @$idlist;
}

### \brief: get Run Info for list of IDs
###
### \param: the LWP::UserAgent
### \param: the IDs
###
### \return: array of Run Info
sub getRunInfo($@)
{
    my $ua = shift;
    return () unless @_;
    
    my $parser = XML::LibXML->new( no_network => 1, no_blanks => 1 );
    my $url = URI->new_abs('esummary.fcgi', EUTILS_URL);
    $url->query_form(retmode => 'json', db => 'sra', id => join(',', @_));

    my $res = $ua->get($url); die $res->status_line unless $res->is_success;
    
    my $obj = decode_json $res->content or die "unexpected response from eutils";
    my $result = $obj->{result} or die "unexpected response from eutils";

    my @rslt = ();
    for (@_) {
        my $obj = $result->{$_} or die "unexpected response from eutils";
        my $xml = $obj->{runs} or die "unexpected response from eutils";
        $xml =~ s/&lt;/</g;
        $xml =~ s/&gt;/>/g;
        $xml =~ s/&amp;/&/g;
        
        my $frag = $parser->parse_balanced_chunk($xml) or die "unexpected response from eutils";
        for my $run ($frag->findnodes('Run')) {
            my $loaded = $run->findvalue('@load_done') or die "unexpected response from eutils";
            my $public = $run->findvalue('@is_public') or die "unexpected response from eutils";
            my $acc = $run->findvalue('@acc') or die "unexpected response from eutils";
            push @rslt, { acc => $acc, public => $public eq 'true', loaded => $loaded eq 'true' };
        }
    }
    return @rslt;
}

### \brief: turns an accession into its constituent run accessions
###
### \param: the query accession
###
### \return: array of run accessions
sub expandAccession($)
{
    my $ua = LWP::UserAgent->new( agent => 'sratoolkit'
                                , parse_head => 0
                                , ssl_opts => { verify_hostname => 0 } );
    return map { $_->{acc} } grep { $_->{loaded} && $_->{public} } getRunInfo($ua, queryEUtils($ua, $_[0]));
}

RUNNING_AS_FASTQ_DUMP:
{
    my $toolpath = which(REAL_FASTQ_DUMP) or help_path(REAL_FASTQ_DUMP, TRUE);
    my %long_arg = (
        '-A' => '--accession',
        '-N' => '--minSpotId',
        '-X' => '--maxSpotId',
        '-W' => '--clip',
        '-M' => '--minReadLen',
        '-R' => '--read-filter',
        '-E' => '--qual-filter',
        '-O' => '--outdir',
        '-Z' => '--stdout',
        '-G' => '--spot-group',
        '-T' => '--group-in-dirs',
        '-K' => '--keep-empty-files',
        '-C' => '--dumpcs',
        '-B' => '--dumpbase',
        '-Q' => '--offset',
        '-F' => '--origfmt',
        '-I' => '--readids',
        '-V' => '--version',
        '-L' => '--log-level',
        '-v' => '--verbose',
        '-+' => '--debug',
        '-h' => '--help',
        '-?' => '--help',
    );
    my %param_has_arg = (
        '--accession' => TRUE,
        '--table' => TRUE,
        '--minSpotId' => TRUE,
        '--maxSpotId' => TRUE,
        '--spot-groups' => TRUE,
        '--minReadLen' => TRUE,
        '--read-filter' => TRUE,
        '--aligned-region' => TRUE,
        '--matepair-distance' => TRUE,
        '--outdir' => TRUE,
        '--offset' => TRUE,
        '--defline-seq' => TRUE,
        '--defline-qual' => TRUE,
        '--log-level' => TRUE,
        '--debug' => TRUE,
        '--dumpcs' => 0, # argument not required
        '--fasta' => 0, # argument not required
    );
    my @params = (); # short params get expanded to long form
    my @args = (); # everything that isn't part of a parameter

    if (!parseArgv('old', @params, @args, %long_arg, %param_has_arg, @ARGV))
    {
        # usage error or user asked for help
        exec {$toolpath} 'fastq-dump', '--help';
        die "can't exec original fastq-dump: $!";
    }
    processAccessions('fastq-dump', $toolpath, @params, @args);
    die "unreachable";
}

RUNNING_AS_FASTERQ_DUMP:
{
    my $toolpath = which(REAL_FASTERQ_DUMP) or help_path(REAL_FASTERQ_DUMP, TRUE);
    my %long_arg = (
        '-o' => '--outfile',
        '-O' => '--outdir',
        '-b' => '--bufsize',
        '-c' => '--curcache',
        '-m' => '--mem',
        '-t' => '--temp',
        '-e' => '--threads',
        '-p' => '--progress',
        '-x' => '--details',
        '-s' => '--split-spot',
        '-S' => '--split-files',
        '-3' => '--split-3',
        '-f' => '--force',
        '-N' => '--rowid-as-name',
        '-P' => '--print-read-nr',
        '-M' => '--min-read-len',
        '-B' => '--bases',
        '-V' => '--version',
        '-L' => '--log-level',
        '-v' => '--verbose',
        '-+' => '--debug',
        '-h' => '--help',
        '-?' => '--help',
    );
    my %param_has_arg = (
        '--outfile' => TRUE,
        '--outdir' => TRUE,
        '--bufsize' => TRUE,
        '--curcache' => TRUE,
        '--mem' => TRUE,
        '--temp' => TRUE,
        '--threads' => TRUE,
        '--min-read-len'=> TRUE,
        '--log-level' => TRUE,
        '--debug' => TRUE,
    );
    my @params = (); # short params get expanded to long form
    my @args = (); # everything that isn't part of a parameter

    if (!parseArgv('new', @params, @args, %long_arg, %param_has_arg, @ARGV))
    {
        # usage error or user asked for help
        exec {$toolpath} 'fasterq-dump', '--help';
        die "can't exec original fasterq-dump: $!";
    }
    processAccessions('fasterq-dump', $toolpath, @params, @args);
    die "unreachable";
}

RUNNING_AS_SAM_DUMP:
{
    my $toolpath = which(REAL_SAM_DUMP) or help_path(REAL_SAM_DUMP, TRUE);
    my %long_arg = (
        '-u' => '--unaligned',
        '-1' => '--primary',
        '-c' => '--cigar-long',
        '-r' => '--header',
        '-n' => '--no-header',
        '-s' => '--seqid',
        '-=' => '--hide-identical',
        '-g' => '--spot-group',
        '-p' => '--prefix',
        '-Q' => '--qual-quant',
        '-V' => '--version',
        '-L' => '--log-level',
        '-v' => '--verbose',
        '-+' => '--debug',
        '-h' => '--help',
        '-?' => '--help',
    );
    my %param_has_arg = (
        '--header-file' => TRUE,
        '--header-comment' => TRUE,
        '--aligned-region' => TRUE,
        '--matepair-distance' => TRUE,
        '--prefix' => TRUE,
        '--qual-quant' => TRUE,
        '--log-level' => TRUE,
        '--debug' => TRUE,
    );
    my @params = (); # short params get expanded to long form
    my @args = (); # everything that isn't part of a parameter

    if (!parseArgv('new', @params, @args, %long_arg, %param_has_arg, @ARGV))
    {
        # usage error or user asked for help
        exec {$toolpath} 'sam-dump', '--help';
        die "can't exec original sam-dump: $!";
    }
    processAccessions('sam-dump', $toolpath, @params, @args);
    die "unreachable";
}

### \brief: process ARGV using fastq-dump style parsing rules
###
### \param: params   - out, by ref; array of parameters
### \param: args     - out, by ref; array of arguments
### \param: longName - by ref; hash mapping short to long parameter names
### \param: hasArg   - by ref; hash specifying which parameters may take arguments
### \param: argv
sub parseArgvOldStyle(\@\@\%\%@)
{
# parameter may be long or short form
# each parameter must be a separate element (always `-X -C`; never `-XC`)
# parameter arguments must follow parameter as a separate element (never `--param=value` or `-Xvalue`)

    my $params = shift;
    my $args = shift;
    my $longArg = shift;
    my $hasArg = shift;

    @$params = ();
    @$args = ();
    
    while (@_) {
        my $param;
        
        if ($_[0] !~ /^-/) { # ordinary argument
            local $_ = shift;
            push @$args, $_;
            next;
        }
        if ($_[0] =~ /^--/) { # long param
            $param = shift;
        }
        else { # short param
            local $_ = shift;
            $param = $longArg->{$_};
        }
        return FALSE if $param eq '--help';
        if (exists $hasArg->{$param}) {
            if ($hasArg->{$param}) { # param requires an argument
                return FALSE unless @_;
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
            elsif (@_ && $_[0] !~ /^-/) {
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
        }
        # this parameter never has an argument or
        # optional argument wasn't given
        push @$params, $param;
    }
    return TRUE;
}

### \brief: process ARGV
###
### \param: style    - style of args parsing: 'old' = like fastq-dump
### \param: params   - out, by ref; array of parameters
### \param: args     - out, by ref; array of arguments
### \param: longName - by ref; hash mapping short to long parameter names
### \param: hasArg   - by ref; hash specifying which parameters may take arguments
### \param: argv
sub parseArgv($\@\@\%\%@)
{
    {
        my $style = shift;
        goto &parseArgvOldStyle if $style eq 'old';
    }
# parameter may be long or short form
# parameter arguments may follow as a separate element
# parameter arguments may be attached to parameter name with an equals
# short form parameter arguments may be attached directly to parameter
# converts short form to long form
# converts `--param=arg` to `--param arg`

    my $params = shift;
    my $args = shift;
    my $longArg = shift;
    my $hasArg = shift;

    @$params = ();
    @$args = ();
    
    while (@_) {        
        unless ($_[0] =~ /^-/) {
            # ordinary argument
            local $_ = shift;
            push @$args, $_;
            next;
        }

        my $param = shift;
        if ($param =~ /^--/ ) {
            if ($param =~ /^(--[^=]+)=(.+)$/) {
                # convert `--param=arg` to `--param arg`
                push @$params, $1, $2;
                next;
            }
        }
        else {
            # short form
            if ($param =~ /^(-.)(.+)$/) {
                $param = $longArg->{$1};
                if (exists $hasArg->{$param}) {
                    # convert short form with concatenated arg to long form with separate arg
                    push @$params, $param, $2;
                    next;
                }
                else {
                    # concatenated short form; put back the remainder
                    unshift @_, "-$2";
                    push @$params, $param;
                    next;
                }
            }
            else {
                $param = $longArg->{$param};
            }
        }
        return FALSE if $param eq '--help';
        if (exists $hasArg->{$param}) {
            if ($hasArg->{$param}) { # argument is required
                return FALSE unless @_;
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
            elsif (@_ && $_[0] !~ /^-/) { # argument is optional
                local $_ = shift;
                push @$params, $param, $_;
                next;
            }
        }
        # this parameter never has an argument or
        # optional argument wasn't given
        push @$params, $param;
    }
    return TRUE;
}

sub help_path($$)
{
    print "could not find $_[0]";
    print $_[1] ? ", which is part of this software distribution\n" : "\n";
    print <<"EOM";
This can be fixed in one of the following ways:
* adding $_[0] to the directory that contains this tool, i.e. $selfpath
* adding the directory that contains $_[0] to the PATH environment variable
* adding $_[0] to the current directory
EOM
    exit 78; # EX_CONFIG from <sysexits.h>
}

### \brief: check if path+file is an executable
###
### \param: executable name
### \param: directory to examine
###
### \return: path+file if it exists and is executable
sub isExecutable($$)
{
    my ($vol, $dirs, undef) = File::Spec->splitpath($_[1], !0);
    local $_ = File::Spec->catpath($vol, $dirs, $_[0]);
    return (-e && -x) ? $_ : undef;
}

### \brief: like shell `which` but checks more than just PATH
###
### \param: executable name
###
### \return: the full path to executable or undef
sub witch($)
{
    my $exe = $_[0];
    my $fullpath;

    ## first check self directory
    $fullpath = isExecutable($exe, $selfpath);
    return $fullpath if $fullpath;

    ## check PATH
    local $_;
    foreach (File::Spec->path()) {
        $fullpath = isExecutable($exe, $_);
        return $fullpath if $fullpath;
    }

    ## lastly check current directory
    return isExecutable($exe, File::Spec->curdir());
}

### \brief: memo-ized which
###
### \param: executable name
###
### \return: the full path to executable or undef
my %which_mem = ();
sub which($)
{
    $which_mem{$_[0]} = witch($_[0]) unless exists $which_mem{$_[0]};
    return $which_mem{$_[0]};
}

### \brief: the info sub-command
###
### \param: command line ARGS
###
### \return: does not return; calls exit
sub info(@)
{
    help('info') unless @_;
    foreach my $query (@_) {
        if ($query =~ /^[DES]RR\d+$/) {
            say "$query is a run";
        }
        else {
            my @runs = expandAccession $query;
            if (@runs) {
                say "$query consists of these ".(0+@runs)." runs:\n".join("\n", @runs);
            }
            else {
                say "nothing found for $query";
            }
        }
    }
    exit 0;
}

### \brief: the extract sub-command
###
### \param: command line ARGS
###
### \return: does not return; calls exit
sub extract(@)
{
    exit 0;
}

### \brief: the help sub-command
###
### \param: command line ARGS
###
### \return: does not return; calls exit
sub help(@)
{
    local $0 = $basename;
    
    goto INFO if $_[0] && $_[0] eq 'info';
    goto FASTQ if $_[0] && $_[0] eq 'fastq';
    goto SAM if $_[0] && $_[0] eq 'sam';
    
    print "Usage: $0 <command> [<args> ...]\n";
    print <<"EOF";
Commands are:
    info  - get info for an SRA accession
    fastq - extract FASTQ from an SRA accession
    sam   - extract SAM from an SRA accession
    
    help <command> - detailed help for <command> or this message
    
About SRA accessions:
    SRA accessions come in several types. Most types are containers of other
    types, except for SRA run accessions which contain sequence data. Only SRA
    run accessions may be extracted. This tool will expand container accessions
    to their constituent run accessions and perform the requested function on
    each.
    
    SRA run accessions can be extracted as FASTQ.
    
    SRA run accessions can be extracted as SAM; if the run contains alignments,
    the alignment information will be in the SAM records for the aligned reads.
    
    SRA does not guarantee that the original read names are preserved. SRA does
    guarantee that the identity of the reads and mate-pairs are preserved.
    
    SRA does not guarantee that the original quality scores are preserved.
    
See also:
    The SRA homepage at NCBI:
    https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi

    The SRA Toolkit homepage, where you may obtain the latest versions of this
    software and related tools:
    https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software
EOF
    exit 0;

  INFO:
    print <<"EOM";
Usage: $0 info <object>
Prints detailed information about an SRA object
EOM
    exit 0;

  FASTQ:
    print <<"EOM";
Usage: $0 fastq <object>
Extract FASTQ from (possibly many) SRA run accessions
EOM
    exit 0;

  SAM:
    print <<"EOM";
Usage: $0 info <object>
Extract SAM from (possibly many) SRA run accessions
EOM
    exit 0;
}

### \brief: prints basic usage message
###
### \return: does not return; calls exit
sub usage()
{
    print "Usage: $basename <command> [<args> ...]\nTry\n   $basename help\n";
    exit 64; # EX_USAGE from <sysexits.h>
}

RUN_TESTS:
eval <<'TESTS';

use Test::Simple tests => 25;
my %long_args = (
    '-h' => '--help',
    '-?' => '--help',
    '-L' => '--log-level',
);
my %param_args = (
    '--log-level' => TRUE,
);
my @params;
my @args;

# which test
ok( witch($basename), 'found self');

# old style args parsing
ok( !parseArgv('old', @params, @args, %long_args, %param_args, qw{ -h }), 'oldstyle: -h returns false' );
ok( !parseArgv('old', @params, @args, %long_args, %param_args, qw{ -? }), 'oldstyle: -? returns false' );
ok( !parseArgv('old', @params, @args, %long_args, %param_args, qw{ --help }), 'oldstyle: --help returns false' );
ok( !parseArgv('old', @params, @args, %long_args, %param_args, qw{ -L }), 'oldstyle: -L without parameter returns false' );
ok( !parseArgv('old', @params, @args, %long_args, %param_args, qw{ --log-level }), 'oldstyle: --log-level without parameter returns false' );

ok( parseArgv('old', @params, @args, %long_args, %param_args, qw{ -L 5 })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    , 'oldstyle: -L 5' );
ok( parseArgv('old', @params, @args, %long_args, %param_args, qw{ --log-level 5 })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    , 'oldstyle: --log-level 5' );
ok( parseArgv('old', @params, @args, %long_args, %param_args, qw{ foobar })
    && 0+@params == 0 && 0+@args == 1 && $args[0] eq 'foobar'
    , 'oldstyle: foobar' );
ok( parseArgv('old', @params, @args, %long_args, %param_args, qw{ -L 5 foo bar })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    && 0+@args == 2 && $args[0] eq 'foo' && $args[1] eq 'bar'
    , 'oldstyle: -L 5 foo bar' );

# new style args parsing
ok( !parseArgv('new', @params, @args, %long_args, %param_args, qw{ -h }), 'newstyle: -h returns false' );
ok( !parseArgv('new', @params, @args, %long_args, %param_args, qw{ -? }), 'newstyle: -? returns false' );
ok( !parseArgv('new', @params, @args, %long_args, %param_args, qw{ --help }), 'newstyle: --help returns false' );
ok( !parseArgv('new', @params, @args, %long_args, %param_args, qw{ --log-level 5 --help }), 'newstyle: --help with other stuff still returns false' );
ok( !parseArgv('new', @params, @args, %long_args, %param_args, qw{ -L }), 'newstyle: -L without parameter returns false' );
ok( !parseArgv('new', @params, @args, %long_args, %param_args, qw{ --log-level }), 'newstyle: --log-level without parameter returns false' );

ok( parseArgv('new', @params, @args, %long_args, %param_args, qw{ -L5 })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    , 'newstyle: -L5' );
ok( parseArgv('new', @params, @args, %long_args, %param_args, qw{ -L 5 })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    , 'newstyle: -L 5' );
ok( parseArgv('new', @params, @args, %long_args, %param_args, qw{ --log-level=5 })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    , 'newstyle: --log-level=5' );
ok( parseArgv('new', @params, @args, %long_args, %param_args, qw{ --log-level 5 })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    , 'newstyle: --log-level 5' );
ok( parseArgv('new', @params, @args, %long_args, %param_args, qw{ foobar })
    && 0+@params == 0 && 0+@args == 1 && $args[0] eq 'foobar'
    , 'newstyle: foobar' );
ok( parseArgv('new', @params, @args, %long_args, %param_args, qw{ -L 5 foo bar })
    && 0+@params == 2 && $params[0] eq '--log-level' && $params[1] eq '5'
    && 0+@args == 2 && $args[0] eq 'foo' && $args[1] eq 'bar'
    , 'newstyle: -L 5 foo bar' );
    
# accession lookup tests
my @runs;
ok( !(@runs = expandAccession('foobar')), 'lookup: nothing found for foobar' );
ok( scalar(@runs = expandAccession('SRS107532')) == 1 && $runs[0] eq 'SRR064437', 'lookup: SRS107532 contains SRR064437' );
sleep(2);
ok( scalar(@runs = expandAccession('SRA000001')) == 3, 'lookup: SRA000001 contains 3 runs' );

TESTS
exit 0;
