/*===========================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
*
* ===========================================================================
*
*/

#include <ngs/ncbi/NGS.hpp>
#include <ngs/ReadCollection.hpp>
#include <ngs/Reference.hpp>
#include <ngs/Alignment.hpp>
#include <ngs/Pileup.hpp>
#include <ngs/PileupEvent.hpp>

#include <kapp/main.h>

#include "ref-cover.vers.h"

#include <iostream>
#include <string.h>

using namespace ngs;

namespace ref_cover
{
    static
    void run ( const String & runName, const String & refName, PileupIterator & pileup )
    {
        for ( int64_t ref_zpos = -1; pileup . nextPileup (); ++ ref_zpos )
        {
            if ( ref_zpos < 0 )
                ref_zpos = pileup . getReferencePosition ();

            uint32_t ref_base_idx = 0;
            char ref_base = pileup . getReferenceBase ();
            switch ( ref_base )
            {
            case 'C': ref_base_idx = 1; break;
            case 'G': ref_base_idx = 2; break;
            case 'T': ref_base_idx = 3; break;
            }

            uint32_t depth = pileup . getPileupDepth ();
            if ( depth != 0 )
            {
                uint32_t base_counts [ 4 ];
                memset ( base_counts, 0, sizeof base_counts );
                uint32_t ins_counts [ 4 ];
                memset ( ins_counts, 0, sizeof ins_counts );
                uint32_t del_cnt = 0;

                char mismatch;
                uint32_t mismatch_idx;

                while ( pileup . nextPileupEvent () )
                {
                    PileupEvent :: PileupEventType et = pileup . getEventType ();
                    switch ( et & 7 )
                    {
                    case PileupEvent :: match:
                        if ( ( et & PileupEvent :: insertion ) != 0 )
                            ++ ins_counts [ ref_base_idx ];
                        break;

                    case PileupEvent :: mismatch:
                        mismatch = pileup . getAlignmentBase ();
                        mismatch_idx = 0;
                        switch ( mismatch )
                        {
                        case 'C': mismatch_idx = 1; break;
                        case 'G': mismatch_idx = 2; break;
                        case 'T': mismatch_idx = 3; break;
                        }
                        ++ base_counts [ mismatch_idx ];
                        if ( ( et & PileupEvent :: insertion ) != 0 )
                            ++ ins_counts [ mismatch_idx ];
                        break;

                    case PileupEvent :: deletion:
                        if ( pileup . getEventIndelType () == PileupEvent :: normal_indel )
                            ++ del_cnt;
                        else
                            -- depth;
                        break;
                    }
                }

                if ( depth != 0 )
                {
                    std :: cout
                        << runName
                        << '\t' << refName
                        << '\t' << ref_zpos + 1
                        << '\t' << ref_base
                        << '\t' << depth
                        << "\t{" << base_counts [ 0 ]
                        << ',' << base_counts [ 1 ]
                        << ',' << base_counts [ 2 ]
                        << ',' << base_counts [ 3 ]
                        << "}\t{" << ins_counts [ 0 ]
                        << ',' << ins_counts [ 1 ]
                        << ',' << ins_counts [ 2 ]
                        << ',' << ins_counts [ 3 ]
                        << "}\t" << del_cnt
                        << '\n'
                        ;
                }
            }
        }
    }

    static
    void run ( const char * spec )
    {
        std :: cerr << "# Opening run '" << spec << "'\n";
        ReadCollection obj = ncbi :: NGS :: openReadCollection ( spec );
        String runName = obj . getName ();

        std :: cerr << "# Accessing all references\n";
        ReferenceIterator ref = obj . getReferences ();

        while ( ref . nextReference () )
        {
            String refName = ref . getCanonicalName ();

            std :: cerr << "# Processing reference '" << refName << "'\n";

            std :: cerr << "# Accessing all pileups\n";
            PileupIterator pileup = ref . getPileups ( Alignment :: all );
            run ( runName, refName, pileup );
        }
    }
}

extern "C"
{
    ver_t CC KAppVersion ()
    {
        return REF_COVER_VERS;
    }

    rc_t CC Usage ( struct Args const * args )
    {
        return 0;
    }

    rc_t CC KMain ( int argc, char *argv [] )
    {
        rc_t rc = 0;

        try
        {
            for ( int i = 1; i < argc; ++ i )
            {
                ref_cover :: run ( argv [ i ] );
            }
        }
        catch ( ErrorMsg & x )
        {
            std :: cerr
                << "ERROR: "
                << argv [ 0 ]
                << ": "
                << x . what ()
                << '\n'
                ;
            rc = -1;
        }
        catch ( ... )
        {
            std :: cerr
                << "ERROR: "
                << argv [ 0 ]
                << ": unknown\n"
                ;
            rc = -1;
        }

        return rc;
    }
}
